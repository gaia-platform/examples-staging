////////////////////////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////////////////////////
// 
// Rules for performing SLAM in the slam simulator.
//
////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include <math.h>

#include <iostream>
#include <string>

#include <gaia/common.hpp>
#include <gaia/logger.hpp>
#include <gaia/rules/rules.hpp>

#include "slam_sim.hpp"


//using slam_sim::select_destination;
//using slam_sim::select_landmark_destination;

// Brings Alice to a halt. Creates new observation at present position.
using slam_sim::full_stop;

// Instructs Alice to beging trek to destination. Motion control is
//  managed at lower level, using direction data determined in rules.
using slam_sim::move_toward_destination;

//using slam_sim::create_new_path;
//using slam_sim::create_observation;
//using slam_sim::init_path;
//
//using slam_sim::calc_path_error;
//using slam_sim::build_area_map;
//using slam_sim::build_local_map;
//using slam_sim::build_working_map;
//
//using gaia::slam::pending_destination_t;
//using gaia::slam::estimated_position_t;
//using gaia::slam::destination_t;
//using gaia::slam::paths_t;
//
//using gaia::slam::paths_writer;


// Wrap error correction and map creation in a serial group as these are
//  expensive operations and we want to avoid concurrent operations 
//  experiencing a txn conflict, and avoid race conditions.
ruleset map_ruleset : serial_group()
{
    // We don't want multiple edges to be created at similar points in time
    //  and both realize that it's time to optimize the map, and do so 
    //  together, so keep the graph optimization check in a serial group.
    on_insert(e: edges)
    {
        // New edge created. See if it's time to run new graph optimization.
        if (optimization_required())
        {
            optimize_graph(e.dest->observations.graph->graphs);

            // Whenever new error-correction data is available, regenerate
            //  maps. This can be triggered in a separate rule or simply
            //  done here, so do it here.
            build_area_map(/area_map, /observed_area);
            build_working_map(/destination, /area_map);
        }
    }


    // Destination changed. Update working map and start moving toward it.
    on_change(d: destination)
    {
        build_working_map(d, /area_map);
        move_toward_destination(/working_map);
    }


    // For each observation, update working map using new sensor data.
    on_insert(o: observations)
    {
        // If working map will go beyond border of area map, rebuild
        //  area map.
        if (need_to_extend_area_map())
        {
            build_area_map(/area_map, /observed_area);
        }
        build_working_map(g, /area_map);
    }
}


ruleset observation_ruleset
{
    ////////////////////////////////////////////
    // Creating observations

    // When our position is updated a new observation will be created.
    // Note that this is a relatively slow operation so hopefully there's
    //  no transaction conflict.
    on_update(ep: estimated_position)
    {
        gaia_log::app().info("Estimated position changed to {},{}", ep.x_meters,
            ep.y_meters);

        // Determine if it's time to build another observation.
        if (should_build_new_observation())
        {
            create_observation(/ego.current_path->paths);
        }
    }

    on_insert(o: observations)
    {
        // TODO Consult working map and update path toward destination.
    }

    on_insert(o: observations)
    {
        // TODO Perform spatial query in area of observation and see if
        //  there are other observations to build edges with.
    }



    ////////////////////////////////////////////
    // Async events

    on_insert(c: collision_event)
    {
        // A collision was detected, or the range sensor detected something
        //  closer than it's supposed to be. Initiate a stop, which will
        //  in turn create a new observation.
        gaia_log::app().info("Collision detected. Stopping bot");
        full_stop();
    }
}
