////////////////////////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////////////////////////
// 
// Rules for performing SLAM in the slam simulator.
//
////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include <math.h>

#include <iostream>
#include <string>

#include <gaia/common.hpp>
#include <gaia/logger.hpp>
#include <gaia/rules/rules.hpp>

#include "globals.hpp"
#include "slam_sim.hpp"

/***********************************************************************
Rules

map_ruleset serial_group
  on_insert(edges)        If optimization required, do so and rebuild maps.
  on_change(destination)  Rebuild area map, move toward new destination.
  on_insert(vertices)     Extend area map if necessary.

ruleset
  on_insert(vertices)     Spatial query to link to other nodes.
  on_insert(vertices)     Determine if it's time to change destination.
  on_insert(collision_event)  Full stop and create vertex.
 

***********************************************************************/

//using slam_sim::build_area_map;
using slam_sim::full_stop;
//using slam_sim::move_toward_destination;
//using slam_sim::need_to_extend_map;
//using slam_sim::optimize_graph;
//using slam_sim::optimization_required;
//using slam_sim::reassess_destination;
//using slam_sim::update_world_area;

//using slam_sim::g_running;


// Wrap error correction and map creation in a serial group as these are
//  expensive operations and we want to avoid concurrent operations 
//  experiencing a txn conflict, and avoid race conditions.
ruleset map_ruleset : serial_group()
{
//    // We don't want multiple edges to be created at similar points in time
//    //  and both edges realize that it's time to optimize the map, so keep 
//    //  the graph optimization check in a serial group.
//    on_insert(edges)
//    {
//printf("1 enter on_insert(edges)\n");
//        // New edge created. See if it's time to run new graph optimization.
//        if (optimization_required())
//        {
//            optimize_graph(edges.dest->vertices.graph->graphs);
//            // Whenever new error-correction data is available, regenerate
//            //  maps. This can be triggered in a separate rule or simply
//            //  done here, so do it here.
//            build_area_map(/destination, /area_map, /observed_area);
//        }
//printf("1 leave on_insert(edges)\n");
//    }
//
//
//    // Destination changed. Update working map and start moving toward it.
//    on_change(destination)
//    {
//printf("2 enter on_change(destination)\n");
//        // Destination's changed. Make sure the known world includes 
//        //  this point.
//        update_world_area(/ego);
//        // Build map, including paths, to destination.
//        build_area_map(/destination, /area_map, /observed_area);
//        // Start movement toward destination.
//        g_running = true;
//printf("2 leave on_change(destination)\n");
//    }
//
//
//    // For each vertex, update working map using new sensor data.
//    on_insert(vertices)
//    {
//printf("3 enter on_insert(vertices)\n");
//        // If working map will go beyond border of area map, rebuild
//        //  area map.
//        if (need_to_extend_map(vertices.position->positions, /observed_area))
//        {
//            build_area_map(/destination, /area_map, /observed_area);
//        }
//printf("3 leave on_insert(vertices)\n");
//    }
}


ruleset runtime_ruleset
{
    // Vertices are created at a lower infrastructure level. The
    //  decision to do so is based on the following assumptions about
    //  when an observation is made:
    //  1) Vertices are generated at locations that provide
    //    non-redundant information about the environment, such as range
    //    data that covers previously unexplored territory or being
    //    near salient landmark to form closures with other nearby
    //    vertices.
    //  2) Sensor data is read at a rate higher than vertices are
    //    created.
    //  3) The time required to evaluate whether or not to make an
    //    observation may be longer than the interval between successive
    //    packets of sensor data.
    // This latter assumption means that one can't directly use a rule
    //  triggering of sensor data to build vertices as these must
    //  run in parallel, risking violation of (1), as other vertices
    //  made during processing will be invisible to the rule's txn.


//    on_insert(vertices)
//    {
//        // TODO Perform spatial query in area of observation and see if
//        //  there are other vertices to build edges with (i.e., build
//        //  loop closures)
//    }
//
//    on_insert(vertices)
//    {
//printf("4 enter on_insert(vertices)\n");
//        // Determine if it's time to change destinations.
//        if (reassess_destination())
//        {
//            // TODO If destination changes, start a new graph.
//        }
//printf("4 leave on_insert(vertices)\n");
//    }

    on_insert(collision_event)
    {
printf("5 enter on_insert(collision_event)\n");
        // A collision was detected, or the range sensor detected something
        //  closer than it's supposed to be. Initiate a stop, which will
        //  in turn create a new observation.
        gaia_log::app().info("Collision detected. Stopping bot");
        full_stop();
printf("5 leave on_insert(collision_event)\n");
    }

//    on_insert(graphs)
//    {
//printf("6 enter on_insert(graphs)\n");
//        /ego.current_graph_id = graphs.id;
//printf("6 leave on_insert(graphs)\n");
//    }
}

