////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////

#include <assert.h>
#include <math.h>

#include <iostream>
#include <string>

#include "gaia/common.hpp"
#include "gaia/rules/rules.hpp"

#include "slam_sim.hpp"


using slam_sim::select_destination;
using slam_sim::select_landmark_destination;
using slam_sim::full_stop;
using slam_sim::move_toward_destination;

using slam_sim::create_new_path;
using slam_sim::create_observation;
using slam_sim::init_path;

using slam_sim::calc_path_error;
using slam_sim::build_area_map;
using slam_sim::build_local_map;
using slam_sim::build_working_map;

using gaia::slam::pending_destination_t;
using gaia::slam::estimated_position_t;
using gaia::slam::destination_t;
using gaia::slam::paths_t;

using gaia::slam::paths_writer;


ruleset observation_ruleset
{
    ////////////////////////////////////////////
    // Change of path state

    on_update(paths.state)
    {
        if (state == slam_sim::PATH_STATE_STARTING)
        {
            // Sanity check. A new path should have no observations.
            uint32_t n = 0xffffffff;
            n = paths.num_observations;
            assert(n == 0);

            // Create first observation. That will trigger the sequence
            //  of events moving toward the destination.
            create_observation();
            paths.state = slam_sim::PATH_STATE_ACTIVE;
        }
    }


    on_update(paths.state)
    {
        if (paths.state == slam_sim::PATH_STATE_DONE)
        {
            // Path just completed. Calculate error and store results
            //  in error_correction. There should be no transaction
            //  conflicts as this is the only code path altering
            //  the record in that table. Once error is calculated
            //  a new area map can be created.
            // TODO make sure this is a full path so that DR errors can
            //  be estimated from it.
            calc_path_error(paths);
        }
    }


    ////////////////////////////////////////////
    // Creating observations

    on_insert(o: observations)
    {
        // An observation of the surroundings was made. Now we need to
        //  move on towards our destination.
        // There are several things to consider. Updating the destination
        //  record will trigger a rebuilding of the local maps, which will
        //  in turn have Alice move toward the destination.

        for (/pending_destination) {
            // If there's a new destination request pending, set that as the
            //  destination.

            // TODO modify destination record
            assert(1 == 0); // induce a fault until this is supported

            return;
        }

        if (o.path->paths.state == slam_sim::PATH_STATE_STARTING)
        {
            // This is a newly created path. Select a destination.
            // Add this observation to the path
            init_path(o);
            // Path initization changes the state to active. This change
            //  doesn't trigger any side actions, so there's nothing to
            //  worry about if we modify another row that will induce
            //  a cascade of rule executions.
            // Select a destination.
            select_destination();
            return;
        }

        if (o.path->paths.state == slam_sim::PATH_STATE_ACTIVE)
        {
            if (o.path->paths.num_observations > expected_arrival)
            {
                // We're exploring and should have reached our destination
                //  already. Give up and go back to a landmark.
                select_landmark_destination();
                return;
            }
        }

        // If we're close enought to a landmark right now, terminate
        //  the path.
        for (o.landmark_sightings->ls:landmark_sightings) {
            if (ls.range_meters < slam_sim::LANDMARK_DISTANCE_METERS) {
                o.path->paths.state = slam_sim::PATH_STATE_DONE;
                return;
            }
        }

        // If position is sufficiently close to destination then stop
        //  exploring and go find a landmark (or if we arrived where one
        //  should be, go look for another one).
        // Both destination and estimated position tables have exactly
        //  on record, so we can use a shortcut to access the fields
        //  in these records directly.
        double dx = 0.0;
        double dy = 0.0;
        dx = /destination.x_meters - /estimated_position.x_meters;
        dy = /destination.y_meters - /estimated_position.y_meters;
        double dist_2 = dx*dx + dy*dy;
        double radius_2 = slam_sim::DESTINATION_RADIUS_METERS
            * slam_sim::DESTINATION_RADIUS_METERS;
        if (dist_2 < radius_2)
        {
            // Arrived at destination. Find a landmark to calibrate
            //  position and then update map.
            select_landmark_destination();
            return;
        }

        // Destination hasn't changed. Rebuild the working map
        //  and proceed.
        build_working_map();
    }


    ////////////////////////////////////////////
    // Setting destination and error correction

    on_update(d: destination)
    {
        // make sure destination and location are w/in map......
        // TODO FIXME using high-res map good for collision avoidance
        //  but it's not sufficient for navigation, e.g., it cannot
        //  guide around long penninsula.
        // Maybe have high-res map that's very local to Alice and
        //  build that from low-res map. Don't worry about destination
        //  being in map. Coarse path can be inheritted from low-res map.
        //  This should save time generating local high-res map.

        build_area_map();
    }


    on_update(e: error_correction)
    {
        // TODO decide what to do next.
        // For now, start a new path and keep exploring.
        create_new_path();
    }


    ////////////////////////////////////////////
    // Map updates

    on_update(a: area_map)
    {
        // Local map was updated. Now rebuild working map.
        build_local_map();
    }


    on_update(m: local_map)
    {
        // Local map was updated. Now rebuild working map.
        build_working_map();
    }


    on_update(w: working_map)
    {
        // Working map was updated. Based on contents of map, move
        //  toward destination.
        // Alice control drops down to procedural code here, with
        //  direction setting, forward motion, and distance travelled
        //  managed at procedural level. When Alice has moved far enough
        //  forward, an observation record will be made.
        move_toward_destination();
    }


    ////////////////////////////////////////////
    // Async events

    on_insert(c: collision_event)
    {
        // A collision was detected, or the range sensor detected something
        //  closer than it's supposed to be. Initiate a stop, which will
        //  in turn create a new observation.
        full_stop();
    }
}
