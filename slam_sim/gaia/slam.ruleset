#include <assert.h>

#include <iostream>
#include <string>

#include "gaia/common.hpp"
#include "gaia/rules/rules.hpp"

#include "slam/gaia_slam.h"

constexpr double ARRIVE_DEST_RADIUS_METERS = 1.0; // TODO move to header


ruleset observation_ruleset // serial_group("observations")
{
    on_update(path.state)
    {
        if (state == PATH_STATE_STARTING)
        {
            // Sanity check. A new path should have no observations.
            assert(path.num_observations == 0);

            // Create first observation. That will trigger the sequence 
            //  of events moving toward the destination.
            create_observation();
            path.state = PATH_STATE_ACTIVE;
        }
        else if (path.state == PATH_STATE_DONE)
        {
            // Path just completed. Calculate error and store results
            //  in error_correction. There should be no transaction
            //  conflicts as this is the only code path altering
            //  the record in that table. Once error is calculated
            //  a new area map can be created.
            calc_path_error(path);
        }
    }


    on_insert(o: observation)
    {
        // An observation of the surroundings was made. Now we need to
        //  move on towards our destination.
        // There are several things to consider. Updating the destination
        //  record will trigger a rebuilding of the local maps, which will
        //  in turn have Alice move toward the destination.

        pending_destination_t new_dest = pending_destination::begin();
        if (new_dest)
        {
            // If there's a new destination request pending, set that as the
            //  destination.

            // TODO modify destination record
        }
        else if (num_observations == 0)
        {
            // This is a newly created path. Select a destination.
            select_destination();
        }
        else if ((state == PATH_STATE_ACTIVE) && 
            (num_observations > expected_arrival))
        {
            // We're exploring and should have reached our destination
            //  already. Give up and go back to a landmark.
            select_landmark_destination();
        }


// TODO if we're close enough to a landmark right now, terminate the path


        else
        {
            // If position is sufficiently close to destination then stop
            //  exploring and go find a landmark (or if we arrived where one
            //  should be, go look for another one).
            estimated_position_t pos = estimated_position_t::list()::begin();
            destination_t dest = desination::list()::begin();
            assert(exists(pos));
            assert(exists(dest));
            double dx = dest.x_meters - pos.x_meters;
            double dy = dest.y_meters - pos.y_meters;
            double dist = sqrt(dx*dx + dy*dy);
            if (dist < ARRIVE_DEST_RADIUS_METERS)
            {
                // Arrived at destination. Find a landmark to calibrate
                //  position and then update map.
                select_landmark_destination();
            }
            else
            {
                // Destination hasn't changed. Rebuild the working map
                //  and proceed.
                update_working_map();
            }
        }
    }


    on_update(d: destination)
    {
        // make sure destination and location are w/in map......
        // TODO FIXME using high-res map good for collision avoidance
        //  but it's not sufficient for navigation, e.g., it cannot
        //  guide around long penninsula. 
        // Maybe have high-res map that's very local to Alice and
        //  build that from low-res map. Don't worry about destination
        //  being in map. Coarse path can be inheritted from low-res map.
        //  This should save time generating local high-res map.

        generate_local_map();
    }


    on_update(m: local_map)
    {
        // Local map was updated. Now rebuild working map.
        generate_working_map();
    }


    on_update(w: working_map)
    {
        // Working map was updated. Based on contents of map, move
        //  toward destination.
        // Alice control drops down to procedural code here, with
        //  direction setting, forward motion, and distance travelled
        //  managed at procedural level. When Alice has moved far enough
        //  forward, an observation record will be made.
        move_toward_destination();
    }


    on_insert(c: collision_event)
    {
        // A collision was detected, or the range sensor detected something
        //  closer than it's supposed to be. Initiate a stop, which will
        //  in turn create a new observation.
        full_stop();
    }



    on_update(e: error_correction)
    {
        // We have a new estimated error. Update our running error estimate.
        update_summary_error();
        // Build a new map w/ our latest error estimate.
        build_area_map();
    }


    on_update(m: area_map)
    {
        // When the area map is updated it's time to create a new path.
        create_new_path();
    }
}

