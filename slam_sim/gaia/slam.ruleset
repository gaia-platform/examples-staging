////////////////////////////////////////////////////////////////////////
// Copyright (c) Gaia Platform LLC
//
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE.txt file
// or at https://opensource.org/licenses/MIT.
////////////////////////////////////////////////////////////////////////
// 
// Rules for performing SLAM in the slam simulator.
//
////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include <math.h>

#include <iostream>
#include <string>

#include <gaia/common.hpp>
#include <gaia/logger.hpp>
#include <gaia/rules/rules.hpp>

#include "slam_sim.hpp"


using slam_sim::optimization_required;
using slam_sim::optimize_graph;

using slam_sim::need_to_extend_map;
using slam_sim::build_area_map;
using slam_sim::build_working_map;

using slam_sim::select_new_destination;
using slam_sim::move_toward_destination;
using slam_sim::full_stop;


/***********************************************************************
Rules

map_ruleset serial_group
  on_insert(edges)        If optimization required, do so and rebuild maps.
  on_change(destination)  Rebuild working map, move to destination.
  on_insert(observation)  Extend area map if necessary.

ruleset
  on_insert(observation)  Spatial query to link to other nodes.
  on_insert(observation)  Determine if it's time to change destination.
  on_insert(collision_event)  Full stop and create observation.
 

***********************************************************************/


// Wrap error correction and map creation in a serial group as these are
//  expensive operations and we want to avoid concurrent operations 
//  experiencing a txn conflict, and avoid race conditions.
ruleset map_ruleset : serial_group()
{
    // We don't want multiple edges to be created at similar points in time
    //  and both realize that it's time to optimize the map, and do so 
    //  together, so keep the graph optimization check in a serial group.
    on_insert(edges)
    {
        // New edge created. See if it's time to run new graph optimization.
        if (optimization_required())
        {
            optimize_graph(edges.dest->observations.graph->graphs);

            // Whenever new error-correction data is available, regenerate
            //  maps. This can be triggered in a separate rule or simply
            //  done here, so do it here.
            build_area_map(/area_map, /observed_area);
            build_working_map(/destination, /area_map);
        }
    }


    // Destination changed. Update working map and start moving toward it.
    on_change(destination)
    {
        build_working_map(destination, /area_map);
        move_toward_destination(/working_map);
    }


    // For each observation, update working map using new sensor data.
    on_insert(observations)
    {
        // If working map will go beyond border of area map, rebuild
        //  area map.
        if (need_to_extend_area_map())
        {
            build_area_map(/area_map, /observed_area);
        }
        build_working_map(/destination, /area_map);
    }
}


ruleset runtime_ruleset
{
    // Observations are created at a lower infrastructure level. The
    //  decision to do so is based on the following assumptions about
    //  when an observation is made:
    //  1) Observations (nodes) are generated at locations that provide
    //    non-redundant information about the environment, such as range
    //    data that covers previously unexplored territory or being
    //    near salient landmark to form closures with other nearby
    //    observations.
    //  2) Sensor data is read at a rate higher than observations are
    //    created.
    //  3) The time required to evaluate whether or not to make an
    //    observation may be longer than the interval between successive
    //    packets of sensor data.
    // This latter assumption means that one can't directly use a rule
    //  triggering of sensor data to build observations as these must
    //  run in parallel, risking violation of (1), as other observations
    //  made during processing will be invisible to the rule's txn.


    on_insert(observations)
    {
        // TODO Perform spatial query in area of observation and see if
        //  there are other observations to build edges with.
    }

    on_insert(observations)
    {
        // Determine if it's time to change destinations.
        select_new_destination();
    }

    on_insert(collision_event)
    {
        // A collision was detected, or the range sensor detected something
        //  closer than it's supposed to be. Initiate a stop, which will
        //  in turn create a new observation.
        gaia_log::app().info("Collision detected. Stopping bot");
        full_stop();
    }
}

